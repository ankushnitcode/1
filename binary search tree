#include <iostream>
#include<queue>
#include <stack>
using namespace std;
class bstnode{
    public:
    int data;
    bstnode* left;
    bstnode* right;
};
bstnode * root=NULL;
bstnode* newnode(int x){
    bstnode* temp;
temp = new bstnode();
temp->data=x;
temp->left=NULL;
temp->right=NULL;
return temp;
}
bstnode*insert(bstnode *root,int x){   //to insert in bst
    if(root==NULL)
    root=newnode(x);
    else if( x<=root->data){
       root->left= insert(root->left,x);}
       else{
           root->right=insert(root->right,x);
       }return root;
    }
  /* int max( bstnode*root){   //find max in bst
       if(root==NULL){
           return 0;
       }
      else if(root->right==NULL){
           return root->data;
       }else {
           return max(root->right);
       }

    }
     int min( bstnode*root){    //fnd min in bst
       if(root==NULL){
           return 0;
       }
      else if(root->left==NULL){
           return root->data;
       }else {
           return min(root->left);
       }

    }*/
     bstnode* bmin( bstnode*root){
       if(root==NULL){
           return NULL;
       }
      else if(root->left==NULL){
           return root;
       }else {
           return bmin(root->left);
       }

    }
  /*  int height(bstnode*root){   //time complexity O(n)   //eight of tree
        if(root==NULL){
            return -1;
        }
       return (height(root->left)>height(root->right))?height(root->left)+1 :height (root->right)+1;

        }
        void levelorder(bstnode*root){    //print level order
           if(root==NULL){
               return ;
           }  queue<bstnode*>q;
           q.push(root);
           while(!q.empty()){
               bstnode*temp=q.front();
               cout<<temp->data<<" ";
               if(temp->left!=NULL){
                   q.push(temp->left);
               }
               if(temp->right!=NULL)
{
    q.push(temp->right);

}  q.pop();         }}*/

void preorder(bstnode*root){     //print preorder
  /*  if(root==NULL){                 alternate solution
               return ;
           }
           stack<bstnode*>s;
           s.push(root);
           while(!s.empty()){
               bstnode*temp=s.top();
               cout<<temp->data<<" ";
                s.pop(); 
                if(temp->right!=NULL){
                   s.push(temp->right);
               }
               if(temp->left!=NULL)
{ s.push(temp->left);
 }   }*/
           if(root==NULL){                 
               return ;
           }
           cout<<root->data<<" ";
           preorder(root->left);
           preorder(root->right);


            }
            void inorder(bstnode* root){
               if(root==NULL){                 
               return ;
           }
           inorder(root->left);
           cout<<root->data<<" ";
           inorder(root->right); 
            }
           
 /*   
bool search(bstnode*root,int x){
    if(root==NULL){
        return false;
    }
  else  if(root->data==x){
        return true;
    }
    else if (x<=root->data){
        return search(root->left,x);
    }
    else{
        return search(root->right,x);
    }}*/
    bstnode* bsearch(bstnode*root,int x){
    if(root==NULL){
        return NULL;
    }
  else  if(root->data==x){
        return root;
    }
    else if (x<=root->data){
        return bsearch(root->left,x);
    }
    else{
        return bsearch(root->right,x);
    }}

     bstnode* bdelete (bstnode*root,int data ){
    if(root == NULL) return root; 
	else if(data < root->data) root->left = bdelete(root->left,data);
	else if (data > root->data) root->right = bdelete(root->right,data);
	// Wohoo... I found you, Get ready to be deleted	
    else{
    if(root->left==NULL&&root->right==NULL){
        delete root;
        root=NULL;

     }
    else if(root->left==NULL){
         bstnode*temp=root;
         root=root->right;
         delete temp;
     }
    else if(root->right==NULL){
         bstnode*temp=root;
         root=root->left;
         delete temp;
     }
     else{
         bstnode*temp=bmin(root->right);
         root->data=temp->data;
         root->right=bdelete(root->right,temp->data);}

     }return root;}

    int main(){
     
      root=  insert(root,20);
        root=  insert(root,15);
        root=  insert(root,25);
        root=  insert(root,8);
        root=  insert(root,17);
        root=  insert(root,23);
        root=  insert(root,30);
        root=  insert(root,27);
        root=  insert(root,40);
      //  levelorder(root);
    //  preorder(root);
   // inorder(root);
   
     //  cout<<check(root)<<endl;
     root=bdelete(root,17);
     inorder(root);
  
      /*  cout<<"enter element you want to search in tree"<<endl;
        int c;
        cin>>c;
        
        if(search(root,c)==true ){
            cout<<"found"<<endl;}
            else{
                cout<<"not found "<<endl;
            }*/
      //cout<<max(root)<<endl;
     // cout<<min(root)<<endl;
//cout<<height(root)<<endl;
      
        }
        
        
    
